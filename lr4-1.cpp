#include <iostream>
#include <vector>
#include <iomanip>
#include <cmath>
using namespace std;

// задаем точность для остановки итераций
const double e = 0.0001;  // погрешность, при достижении которой считаем, что нашли корень

// функция, корни которой ищем
double f(double x) {
    return sin(x) - 2 * x - 1;  // возвращает значение функции в точке x
}

// производная функции для метода Ньютона
double f1(double x) {
    return cos(x) - 2;  // возвращает значение производной функции в точке x
}

// функция для метода простых итераций
double phi(double x) {
    return (sin(x) - 1) / 2;  // преобразование уравнения к виду x = phi(x)
}

// реализуем метод половинного деления
int halfdivision(double a, double b, vector<double>& roots) {
    // проверяем условие применимости метода: f(a) и f(b) должны иметь разные знаки
    if (f(a) * f(b) >= 0.0) {
        cout << "неверный интервал для метода половинного деления" << endl;
        return 0;  // возвращаем 0, если условие не выполнено
    }

    int k = 0;  // счетчик итераций
    double c;   // переменная для хранения середины интервала

    // выводим заголовок таблицы
    cout << "программа уточнения корня методом половинного деления" << endl;
    cout << setw(2) << "n" << " | " << setw(7) << "an" << " | ";
    cout << setw(9) << "bn" << " | " << "bn - an" << endl;

    // цикл, пока длина интервала не станет меньше заданной точности
    while (abs(b - a) >= e) {
        c = (a + b) / 2;  // находим середину интервала
        // выводим текущие значения интервала и его длину
        cout << setw(2) << k << " | " << fixed;
        cout << setprecision(4) << setw(7) << a << " | ";
        cout << setw(9) << b << " | " << abs(b - a) << endl;

        // если значение функции в точке c равно нулю, нашли точный корень
        if (f(c) == 0.0) break;

        // выбираем новый интервал в зависимости от знака функции
        if (f(c) * f(a) < 0) {
            b = c;  // корень в левой части
        } else {
            a = c;  // корень в правой части
        }
        k++;  // увеличиваем счетчик итераций
    }

    // сохраняем найденный корень в контейнер
    roots.push_back(c);
    // выводим результат
    cout << "корень " << fixed << setprecision(4) << c;
    cout << " с " << k << " итерациями" << endl;
    return k;  // возвращаем число итераций
}

// реализуем метод Ньютона
int newtonmethod(double x0, vector<double>& roots) {
    int k = 0;  // счетчик итераций
    double x1 = x0 - f(x0) / f1(x0);  // вычисляем следующее приближение

    // выводим заголовок таблицы
    cout << endl << "программа уточнения корня методом ньютона" << endl;
    cout << setw(2) << "n" << " | " << setw(7) << "xn" << " | ";
    cout << setw(9) << "xn+1" << " | " << "xn+1 - xn" << endl;

    // цикл, пока разница между приближениями не станет меньше точности
    while (abs(x1 - x0) > e) {
        // выводим текущие значения
        cout << setw(2) << k << " | " << fixed;
        cout << setprecision(4) << setw(7) << x0 << " | ";
        cout << setw(9) << x1 << " | " << abs(x1 - x0) << endl;

        x0 = x1;  // обновляем x0 для следующей итерации
        x1 = x0 - f(x0) / f1(x0);  // вычисляем новое приближение
        k++;  // увеличиваем счетчик
    }

    // сохраняем найденный корень
    roots.push_back(x1);
    // выводим результат
    cout << "корень " << fixed << setprecision(4) << x1;
    cout << " с " << k << " итерациями" << endl;
    return k;  // возвращаем число итераций
}

// реализуем метод простых итераций
int simpleiterations(double x0, vector<double>& roots) {
    int k = 0;  // счетчик итераций
    double x1 = phi(x0);  // вычисляем следующее приближение

    // выводим заголовок таблицы
    cout << endl << "метод простых итераций" << endl;
    cout << setw(2) << "n" << " | " << setw(7) << "xn" << " | ";
    cout << setw(9) << "xn+1" << " | " << "xn+1 - xn" << endl;

    // цикл, пока разница между приближениями не станет меньше точности
    while (abs(x1 - x0) > e) {
        // выводим текущие значения
        cout << setw(2) << k << " | " << fixed;
        cout << setprecision(4) << setw(7) << x0 << " | ";
        cout << setw(9) << x1 << " | " << abs(x1 - x0) << endl;

        x0 = x1;  // обновляем x0
        x1 = phi(x0);  // вычисляем следующее приближение
        k++;  // увеличиваем счетчик
    }

    // сохраняем корень
    roots.push_back(x1);
    // выводим результат
    cout << "корень " << fixed << setprecision(4) << x1;
    cout << " с " << k << " итерациями" << endl;
    return k;  // возвращаем число итераций
}

int main() {
    setlocale(LC_ALL, "ru_RU.UTF-8");  // устанавливаем русскую локаль для корректного отображения
    vector<double> roots;  // создаем контейнер для хранения корней
    int s1, s2, s3;  // переменные для количества итераций каждого метода

    // применяем метод половинного деления на интервале [-2, 0]
    s1 = halfdivision(-2, 0, roots);
    // применяем метод Ньютона с начальным приближением -1
    s2 = newtonmethod(-1, roots);
    // применяем метод простых итераций с начальным приближением -1
    s3 = simpleiterations(-1, roots);

    // выводим все найденные корни
    cout << endl << "все корни уравнения" << endl;
    // используем range-based for для обхода контейнера
    for (const auto& root : roots) {
        cout << fixed << setprecision(4) << root << " ";
    }
    cout << endl;

    // выводим сравнение скорости сходимости методов
    cout << endl << "скорость сходимости:" << endl;
    cout << "у ньютона " << s2 << " итераций" << endl;
    cout << "у метода простых итераций " << s3 << " итераций" << endl;
    cout << "у метода половинного деления " << s1 << " итераций" << endl;

    // определяем самый быстрый метод
    if (s1 < s2 && s1 < s3) {
        cout << "метод половинного деления самый быстрый" << endl;
    } else if (s2 < s1 && s2 < s3) {
        cout << "метод ньютона самый быстрый" << endl;
    } else {
        cout << "метод простых итераций самый быстрый" << endl;
    }

    return 0;  // завершение программы
}
