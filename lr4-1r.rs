
use std::vec::Vec;        // для работы с векторами

// задаем точность вычислений
const EPS: f64 = 0.0001; // погрешность для остановки итераций

// объявляем функцию, корни которой будем искать
fn func(x: f64) -> f64 {
    // вычисляем значение функции sin(x) - 2x - 1 в точке x
    x.sin() - 2.0 * x - 1.0
}

// объявляем производную функции для метода ньютона
fn dfunc(x: f64) -> f64 {
    // вычисляем производную cos(x) - 2 в точке x
    x.cos() - 2.0
}

// объявляем функцию для метода простых итераций
fn phi(x: f64) -> f64 {
    // преобразуем уравнение к виду x = (sin(x) - 1)/2
    (x.sin() - 1.0) / 2.0
}

// реализуем метод половинного деления
fn half_div(mut a: f64, mut b: f64, roots: &mut Vec<f64>) -> usize {
    // проверяем условие применимости метода
    if func(a) * func(b) >= 0.0 {
        // выводим сообщение об ошибке, если условие не выполняется
        println!("неверный интервал для метода половинного деления");
        return 0;
    }

    // инициализируем счетчик итераций
    let mut k = 0;
    // объявляем переменную для середины отрезка
    let mut c;

    // выводим заголовок таблицы
    println!("программа уточнения корня методом половинного деления");
    println!("{:2} | {:7} | {:9} | {}", "n", "an", "bn", "bn - an");

    // начинаем итерационный процесс
    while (b - a).abs() >= EPS {
        // вычисляем середину текущего отрезка
        c = (a + b) / 2.0;
        
        // выводим текущее состояние
        println!("{:2} | {:.4} | {:.4} | {:.4}", k, a, b, (b - a).abs());

        // проверяем, не нашли ли точный корень
        if func(c) == 0.0 { break; }

        // выбираем новый интервал
        if func(c) * func(a) < 0.0 {
            // корень в левой половине
            b = c;
        } else {
            // корень в правой половине
            a = c;
        }

        // увеличиваем счетчик итераций
        k += 1;
    }

    // сохраняем найденный корень
    let root = (a + b) / 2.0;
    roots.push(root);
    // выводим результат
    println!("корень {:.4} с {} итерациями", root, k);
    
    // возвращаем количество итераций
    k
}

// реализуем метод ньютона
fn newton(mut x: f64, roots: &mut Vec<f64>) -> usize {
    // инициализируем счетчик итераций
    let mut k = 0;
    // вычисляем первое приближение
    let mut x_new = x - func(x) / dfunc(x);

    // выводим заголовок таблицы
    println!("\nпрограмма уточнения корня методом ньютона");
    println!("{:2} | {:7} | {:9} | {}", "n", "xn", "xn+1", "xn+1 - xn");

    // начинаем итерационный процесс
    while (x_new - x).abs() > EPS {
        // выводим текущее состояние
        println!("{:2} | {:.4} | {:.4} | {:.4}", k, x, x_new, (x_new - x).abs());

        // обновляем значения для следующей итерации
        x = x_new;
        // вычисляем следующее приближение
        x_new = x - func(x) / dfunc(x);
        // увеличиваем счетчик итераций
        k += 1;
    }

    // сохраняем найденный корень
    roots.push(x_new);
    // выводим результат
    println!("корень {:.4} с {} итерациями", x_new, k);
    
    // возвращаем количество итераций
    k
}

// реализуем метод простых итераций
fn simple_iter(mut x: f64, roots: &mut Vec<f64>) -> usize {
    // инициализируем счетчик итераций
    let mut k = 0;
    // вычисляем первое приближение
    let mut x_new = phi(x);

    // выводим заголовок таблицы
    println!("\nметод простых итераций");
    println!("{:2} | {:7} | {:9} | {}", "n", "xn", "xn+1", "xn+1 - xn");

    // начинаем итерационный процесс
    while (x_new - x).abs() > EPS {
        // выводим текущее состояние
        println!("{:2} | {:.4} | {:.4} | {:.4}", k, x, x_new, (x_new - x).abs());

        // обновляем значения для следующей итерации
        x = x_new;
        // вычисляем следующее приближение
        x_new = phi(x);
        // увеличиваем счетчик итераций
        k += 1;
    }

    // сохраняем найденный корень
    roots.push(x_new);
    // выводим результат
    println!("корень {:.4} с {} итерациями", x_new, k);
    
    // возвращаем количество итераций
    k
}

// главная функция программы
fn main() {
    // создаем вектор для хранения корней
    let mut roots = Vec::new();
    // переменные для хранения количества итераций
    let s1;
    let s2;
    let s3;

    // применяем метод половинного деления на интервале [-2, 0]
    s1 = half_div(-2.0, 0.0, &mut roots);

    // применяем метод ньютона с начальным приближением -1
    s2 = newton(-1.0, &mut roots);

    // применяем метод простых итераций с начальным приближением -1
    s3 = simple_iter(-1.0, &mut roots);

    // выводим все найденные корни
    println!("\nвсе корни уравнения");
    for root in &roots {
        print!("{:.4} ", root);
    }
    println!();

    // сравниваем методы по количеству итераций
    println!("\nскорость сходимости:");
    println!("у ньютона {} итераций", s2);
    println!("у метода простых итераций {} итераций", s3);
    println!("у метода половинного деления {} итераций", s1);

    // определяем самый быстрый метод
    if s1 < s2 && s1 < s3 {
        println!("метод половинного деления самый быстрый");
    } else if s2 < s1 && s2 < s3 {
        println!("метод ньютона самый быстрый");
    } else {
        println!("метод простых итераций самый быстрый");
    }
}