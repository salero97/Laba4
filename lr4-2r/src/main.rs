use rand::Rng; // трейт для генерации случайных чисел
use rand::rngs::StdRng; // стандартный генератор случайных чисел
use rand::SeedableRng; // трейт для инициализации генератора
use std::f64; // модуль для работы с числами f64

fn main() {
    // пункт 1: создание и заполнение вектора случайными числами
    
    // создаем генератор случайных чисел с системным источником энтропии
    let mut rng = StdRng::from_entropy();
    
    // задаем размер вектора (n >= 20 по условию)
    let n = 20;
    
    // создаем вектор с начальной емкостью n для хранения чисел f64
    let mut numbers: Vec<f64> = Vec::with_capacity(n);
    
    // заполняем вектор случайными числами от -250 до 250 включительно
    for _ in 0..n {
        // gen_range использует диапазон с ..= для включения верхней границы
        numbers.push(rng.gen_range(-250.0..=250.0));
    }
    
    // выводим исходный массив с форматированием (2 знака после запятой)
    println!("исходный массив: {:.2?}", numbers);

    // пункт 2: подсчет отрицательных элементов
    
    // фильтруем элементы меньше 0 и подсчитываем их количество
    let neg_count = numbers.iter().filter(|&&x| x < 0.0).count();
    println!("количество отрицательных элементов: {}", neg_count);

    // пункт 2: поиск минимального по модулю элемента
    
    // находим индекс элемента с минимальным абсолютным значением
    let min_abs_index = numbers
        .iter() // создаем итератор по элементам
        .enumerate() // добавляем индексы к элементам
        .min_by(|(_, a), (_, b)| // ищем минимальный по модулю
            a.abs().partial_cmp(&b.abs()).unwrap())
        .map(|(index, _)| index) // извлекаем только индекс
        .unwrap(); // безопасное извлечение (n >= 20 по условию)
    
    println!("индекс минимального по модулю элемента: {}", min_abs_index);

    // пункт 2: сумма модулей элементов после минимального
    
    // пропускаем элементы до min_abs_index + 1 и суммируем модули
    let sum_after_min_abs: f64 = numbers
        .iter()
        .skip(min_abs_index + 1)
        .map(|x| x.abs())
        .sum();
    
    println!("сумма модулей элементов после минимального по модулю: {:.2}", sum_after_min_abs);

    // пункт 3: поиск самой длинной убывающей последовательности
    
    let mut max_len = 1; // длина максимальной последовательности
    let mut current_len = 1; // длина текущей последовательности
    let mut start_index = 0; // индекс начала максимальной последовательности
    let mut end_index = 0; // индекс конца максимальной последовательности

    // проходим по массиву начиная со второго элемента
    for i in 1..numbers.len() {
        if numbers[i] < numbers[i - 1] {
            // если последовательность продолжается
            current_len += 1;
            
            // проверяем, стала ли текущая последовательность длиннее максимальной
            if current_len > max_len {
                max_len = current_len;
                // исправление: вычисляем start_index без переполнения
                start_index = i + 1 - max_len;
                end_index = i;
            }
        } else {
            // последовательность прервалась - сбрасываем счетчик
            current_len = 1;
        }
    }

    // выводим найденную последовательность с форматированием
    println!(
        "самая длинная убывающая последовательность: {:.2?}",
        &numbers[start_index..=end_index]
    );
    
    // выводим индексы начала и конца
    println!("индексы начала и конца: {} - {}", start_index, end_index);

    // пункт 4: создание обратной последовательности
    
    // берем срез, разворачиваем и копируем в новый вектор
    let reversed_sequence: Vec<f64> = numbers[start_index..=end_index]
        .iter()
        .rev()
        .cloned()
        .collect();
    
    println!("обращенная последовательность: {:.2?}", reversed_sequence);

    // пункт 5: циклический сдвиг двух массивов
    
    // создаем два тестовых массива
    let mut arr1 = vec![1.0, 2.0, 3.0, 4.0, 5.0];
    let mut arr2 = vec![1.0, 2.0, 3.0];

    println!("первый массив до сдвига: {:?}", arr1);
    println!("второй массив до сдвига: {:?}", arr2);

    // функция для циклического сдвига вправо
    fn shift_right(arr: &mut Vec<f64>) {
        if !arr.is_empty() {
            let last = arr.pop().unwrap();
            arr.insert(0, last);
        }
    }

    // выполняем сдвиг для обоих массивов
    shift_right(&mut arr1);
    shift_right(&mut arr2);

    println!("первый массив после сдвига: {:?}", arr1);
    println!("второй массив после сдвига: {:?}", arr2);
}
